CREATE OR REPLACE DIRECTORY data_dir AS '/u01/app';

SELECT directory_name, directory_path
FROM all_directories
WHERE directory_name = 'DATA_DIR';

CREATE TABLE projet_overview (
    DeviceTimeStamp CHAR(20),
    OTI NUMBER,
    WTI NUMBER,
    ATI NUMBER,
    OLI NUMBER,
    OTI_A NUMBER,
    OTI_T NUMBER,
    MOG_A NUMBER
)
ORGANIZATION EXTERNAL
(
    TYPE ORACLE_LOADER
    DEFAULT DIRECTORY data_dir
    ACCESS PARAMETERS
    (
        RECORDS DELIMITED BY NEWLINE
        FIELDS TERMINATED BY ',' OPTIONALLY ENCLOSED BY '"'
        MISSING FIELD VALUES ARE NULL
        (DeviceTimeStamp CHAR(20),
         OTI FLOAT,
         WTI FLOAT,
         ATI FLOAT,
         OLI FLOAT,
         OTI_A FLOAT,
         OTI_T FLOAT,
         MOG_A FLOAT)
    )
    LOCATION ('Overview.csv')
)
REJECT LIMIT UNLIMITED;

--Phase 4.4 
--Création de la table snapshots 
CREATE TABLE snapshots (
    id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    image BLOB,
    timestamp TIMESTAMP
);

--Récupérer le snapshots GET
SELECT id,
       TO_CHAR(timestamp, 'YYYY-MM-DD HH24:MI:SS') AS ts,
       BLOB_TO_BASE64_PARTS(image) AS base64_image
FROM snapshots;
CREATE OR REPLACE PROCEDURE SAVE_SNAPSHOT(image_base64 CLOB, ts VARCHAR2) IS
    decoded_image BLOB;
BEGIN
    -- Conversion explicite du timestamp reçu
    INSERT INTO snapshots (image, timestamp)
    VALUES (
        BASE64DECODECLOBTOTOBLOB(image_base64),
        TO_DATE(ts, 'YYYY-MM-DD HH24:MI:SS')
    );

    COMMIT;
END;
/

--Pour fichiers trop volumineux 
CREATE OR REPLACE FUNCTION BLOB_TO_BASE64_PARTS(blob_data IN BLOB) RETURN CLOB IS
    clob_data CLOB;
    blob_len INTEGER;
    piece_len CONSTANT INTEGER := 32767; -- Limite de taille par morceau
    offset INTEGER := 1;
BEGIN
    blob_len := DBMS_LOB.GETLENGTH(blob_data);
    DBMS_LOB.CREATETEMPORARY(clob_data, TRUE);
    
    WHILE offset <= blob_len LOOP
        DBMS_LOB.WRITEAPPEND(
            clob_data,
            LEAST(piece_len, blob_len - offset + 1),
            UTL_RAW.CAST_TO_VARCHAR2(DBMS_LOB.SUBSTR(blob_data, LEAST(piece_len, blob_len - offset + 1), offset))
        );
        offset := offset + piece_len;
    END LOOP;

    RETURN clob_data;
END;
/

